<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelvin&#39;s blog</title>
  
  <subtitle>Never stop leanring</subtitle>
  <link href="http://hurk.top/atom.xml" rel="self"/>
  
  <link href="http://hurk.top/"/>
  <updated>2021-12-30T13:57:10.576Z</updated>
  <id>http://hurk.top/</id>
  
  <author>
    <name>HuIsKelvin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python-基于 struct 模块的自定义网络协议打包和解包</title>
    <link href="http://hurk.top/2021/12/30/python-pack-data-by-struct/"/>
    <id>http://hurk.top/2021/12/30/python-pack-data-by-struct/</id>
    <published>2021-12-30T13:19:30.000Z</published>
    <updated>2021-12-30T13:57:10.576Z</updated>
    
    <content type="html"><![CDATA[<p><code>python</code> 中的 <code>struct</code> 模块主要是用来处理 <code>C</code> 结构数据的。使用该 <code>struct</code> 模块，将 Python 数据打包为二进制数据，或者将二进制数据解包为 Python 数据，可用于网络的二进制流传输。</p><span id="more"></span><h2 id="struct-模块"><a href="#struct-模块" class="headerlink" title="struct 模块"></a>struct 模块</h2><p><code>struct</code> 的使用和相关 <code>api</code> 可以查看<a href="https://docs.python.org/zh-cn/3/library/struct.html">官方文档</a>。</p><h2 id="自定义网络协议"><a href="#自定义网络协议" class="headerlink" title="自定义网络协议"></a>自定义网络协议</h2><p>在实际使用中，一般会自定义自己的网络协议，以实现业务需求。一个数据包中包括协议头和数据内容两部分。</p><p>一个最简单的协议头可以包括：数据包类型 <code>type</code> 和数据内容长度 <code>content length</code>。</p><p>一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 协议头的相关变量 &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 数据包类型</span></span><br><span class="line">header_type = <span class="string">&quot;t01&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)     <span class="comment"># 注意，pack 时的字符串 string 要先转换为字节类型</span></span><br><span class="line"><span class="comment"># 数据内容长度</span></span><br><span class="line">header_content_len = <span class="number">0</span></span><br><span class="line"><span class="comment"># 协议头自己的长度</span></span><br><span class="line">header_len = (<span class="built_in">len</span>(header_type)+<span class="number">1</span>) + <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; pack &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 传输的数据</span></span><br><span class="line">msg = <span class="string">&quot;HelloStruct&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pack</span></span><br><span class="line">header_content_len = <span class="built_in">len</span>(msg)</span><br><span class="line">pack_formatter = <span class="string">&quot;&#123;&#125;si&#123;&#125;s&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(header_type),</span><br><span class="line">                            header_content_len)</span><br><span class="line">pack_bytes = struct.pack(pack_formatter, </span><br><span class="line">                        header_type, </span><br><span class="line">                        header_content_len, </span><br><span class="line">                        msg)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pack msg: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(msg))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; unpack &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 解包读取协议头</span></span><br><span class="line">unpack_formatter = <span class="string">&quot;&#123;&#125;si&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(header_type))</span><br><span class="line">unheader_type, unpack_content_len = struct.unpack_from(unpack_formatter, </span><br><span class="line">                                                    pack_bytes, </span><br><span class="line">                                                    offset=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据协议头读取传输的数据内容</span></span><br><span class="line">unpack_msg, = struct.unpack_from(<span class="string">f&quot;<span class="subst">&#123;unpack_content_len&#125;</span>s&quot;</span>, </span><br><span class="line">                                pack_bytes, </span><br><span class="line">                                offset=header_len)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;get msg: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(unpack_msg.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.python.org/zh-cn/3/library/struct.html">struct — 将字节串解读为打包的二进制数据</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;python&lt;/code&gt; 中的 &lt;code&gt;struct&lt;/code&gt; 模块主要是用来处理 &lt;code&gt;C&lt;/code&gt; 结构数据的。使用该 &lt;code&gt;struct&lt;/code&gt; 模块，将 Python 数据打包为二进制数据，或者将二进制数据解包为 Python 数据，可用于网络的二进制流传输。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://hurk.top/tags/python/"/>
    
    <category term="网络传输" scheme="http://hurk.top/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>python-使用 logging 模块打印日志</title>
    <link href="http://hurk.top/2021/12/27/python-logging-example/"/>
    <id>http://hurk.top/2021/12/27/python-logging-example/</id>
    <published>2021-12-27T02:23:06.000Z</published>
    <updated>2021-12-27T02:32:09.941Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="自定义-Logger-类"><a href="#自定义-Logger-类" class="headerlink" title="自定义 Logger 类"></a>自定义 Logger 类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/logging.html">logging — Logging facility for Python</a></li><li><a href="https://blog.csdn.net/modiziri/article/details/48055191">Python 打 log</a></li><li><a href="https://blog.csdn.net/pansaky/article/details/90710751">python 日志 logging模块(详细解析)</a></li><li><a href="https://blog.csdn.net/weixin_43844838/article/details/107240485">log日志的使用-python</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;自定义-Logger-类&quot;&gt;&lt;a href=&quot;#自定义-Logger-类&quot; class=&quot;headerlink&quot; title=&quot;自定义 Logger 类&quot;&gt;&lt;/a&gt;自定义 Logger 类&lt;/h2&gt;&lt;figure </summary>
      
    
    
    
    
    <category term="python" scheme="http://hurk.top/tags/python/"/>
    
    <category term="log" scheme="http://hurk.top/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>docker - 端口映射出现错误</title>
    <link href="http://hurk.top/2021/11/19/docker-port-error/"/>
    <id>http://hurk.top/2021/11/19/docker-port-error/</id>
    <published>2021-11-19T08:08:37.000Z</published>
    <updated>2021-11-19T10:31:46.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>遇到一个情况，在 <code>docker</code> 启动容器时，进行端口映射，出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: driver failed programming external connectivity on endpoint quirky_allen</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>根据网上的资料说，</p><blockquote><p>docker服务启动时定义的自定义链 DOCKER由于某种原因被清掉。<br>重启docker服务及可重新生成自定义链 DOCKER。</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>重启 <code>docker</code> 服务，再启动容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://blog.csdn.net/whatday/article/details/86762264">docker端口映射或启动容器时报错 driver failed programming external connectivity on endpoint quirky_allen</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;遇到一个情况，在 &lt;code&gt;docker&lt;/code&gt; 启动容器时，进行端口映射，出现以下错误&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    
    <category term="docker" scheme="http://hurk.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github Page 配置博客的个人域名</title>
    <link href="http://hurk.top/2021/10/27/frontend-hexo-cname/"/>
    <id>http://hurk.top/2021/10/27/frontend-hexo-cname/</id>
    <published>2021-10-27T12:43:46.000Z</published>
    <updated>2021-10-27T13:12:16.332Z</updated>
    
    <content type="html"><![CDATA[<p>如果有自己的域名，并解析到 Github Page 的域名（<code>your_name.github.io</code>）上时，直接使用 <code>hexo deploy</code> 部署博客，每次都会覆盖掉 <code>CNAME</code>。</p><p>以下将解决这个问题。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在 <code>GitHub</code> 的 <code>repo</code> 中，设置 <code>GitHub Page</code> 并自定义自己的域名，如下图所示。</p><p><img src="/2021/10/27/frontend-hexo-cname/github_page_setting_cname.png" alt="github page setting cname"></p><p>但是这种方法，每次 <code>hexo deploy</code> 之后，都会覆盖掉生成的 <code>CNAME</code>。每次都要重新设置，非常麻烦。</p><p>解决方法：</p><ol><li>手动配置 <code>CNAME</code> 文件</li><li><code>hexo-generator-cname</code> 插件</li></ol><span id="more"></span><h2 id="1-手动配置-CNAME-文件"><a href="#1-手动配置-CNAME-文件" class="headerlink" title="1 手动配置 CNAME 文件"></a>1 手动配置 <code>CNAME</code> 文件</h2><p>在 <code>source</code> 文件夹下，创建 <code>CNAME</code> 文件，并写入自己的域名。</p><p>栗子，<code>CNAME</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hurk.top  # 我自己的域名</span><br></pre></td></tr></table></figure><h2 id="2-使用-hexo-generator-cname-插件"><a href="#2-使用-hexo-generator-cname-插件" class="headerlink" title="2 使用 hexo-generator-cname 插件"></a>2 使用 <code>hexo-generator-cname</code> 插件</h2><p>安装插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>然后，配置 <code>_config.yml</code> 文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用插件</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-cname</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置想用的域名</span></span><br><span class="line"><span class="comment"># 如果默认用 Github Page，则是 https://your_github_name.github.io</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://hurk.top</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/chengxs/p/7496265.html">github+hexo搭建自己的博客网站（七）注意事项（避免read.me，CNAME文件的覆盖，手动改github page的域名）</a></li><li><a href="https://blog.csdn.net/aealen/article/details/105516944">Hexo在部署到Github后CNAME文件会消失或改变的解决方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果有自己的域名，并解析到 Github Page 的域名（&lt;code&gt;your_name.github.io&lt;/code&gt;）上时，直接使用 &lt;code&gt;hexo deploy&lt;/code&gt; 部署博客，每次都会覆盖掉 &lt;code&gt;CNAME&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下将解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;GitHub&lt;/code&gt; 的 &lt;code&gt;repo&lt;/code&gt; 中，设置 &lt;code&gt;GitHub Page&lt;/code&gt; 并自定义自己的域名，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/10/27/frontend-hexo-cname/github_page_setting_cname.png&quot; alt=&quot;github page setting cname&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是这种方法，每次 &lt;code&gt;hexo deploy&lt;/code&gt; 之后，都会覆盖掉生成的 &lt;code&gt;CNAME&lt;/code&gt;。每次都要重新设置，非常麻烦。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动配置 &lt;code&gt;CNAME&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexo-generator-cname&lt;/code&gt; 插件&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="blog" scheme="http://hurk.top/tags/blog/"/>
    
    <category term="hexo" scheme="http://hurk.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中使用本地图片</title>
    <link href="http://hurk.top/2021/10/26/frontend-hexo-local-image/"/>
    <id>http://hurk.top/2021/10/26/frontend-hexo-local-image/</id>
    <published>2021-10-26T12:25:27.000Z</published>
    <updated>2021-10-27T12:45:02.260Z</updated>
    
    <content type="html"><![CDATA[<p>在 hexo 博客中插入博客，可以使用<strong>图床</strong>和<strong>本地图片</strong>两种方式。而图床可能由于网络原因导致加载问题，并且需要另外管理。所以，尝试使用本地的图片。</p><span id="more"></span><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1 概览"></a>1 概览</h2><p>在 hexo 搭建的博客中使用本地图片，主要有几种方式：</p><ol><li>在 <code>source/img</code> 文件夹中放置图片。</li><li>使用插件 <code>hexo-asset-image</code>。</li></ol><h3 id="2-source-img-文件夹"><a href="#2-source-img-文件夹" class="headerlink" title="2 source/img 文件夹"></a>2 <code>source/img</code> 文件夹</h3><p>在本地 <code>source</code> 文件夹下面，新建 <code>img</code> 文件夹，用于存放照片。</p><p>假设有一张照片 <code>source/img/logo.jpg</code>。</p><p>在文章的 <code>markdown</code> 中，使用</p><ul><li><code>![logo](/img/logo.jpg)</code></li><li><code>&lt;img src=&quot;/img/logo.jpg&quot;&gt;</code></li></ul><p>插入图片。</p><img src="/img/logo.png" style="width:50px;margin:15px;"><p>上面<u>这张图片</u>就是以这种方式插入。</p><h3 id="3-hexo-asset-image-插件"><a href="#3-hexo-asset-image-插件" class="headerlink" title="3 hexo-asset-image 插件"></a>3 <code>hexo-asset-image</code> 插件</h3><p>首先，安装插件 <code>hexo-asset-image</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm install hexo-asset-image --save</span></span><br><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>然后在 <code>_config.yml</code> 中加入 <code>post_asset_folder: true</code>。</p><p>之后，用<code>hexo new post_title</code>（post_title 就是文章标题）新建文章时，会在 <code>source/_post</code> 下生成一个同名文件夹 <code>source/_post/post_title</code>。可以把这篇文章用到的图片，放入此文件夹中，如图片 <code>test.png</code>。</p><p>那么，在文章的 markdown 中插入图片。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">test.png</span>)</span><br><span class="line">&lt;!-- 或 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.png&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><img src="/2021/10/26/frontend-hexo-local-image/test.png" style="width:50px;margin:15px;"><p>上面<u>这张图片</u>就是以这种方式插入。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/codehome/p/8428738.html?utm_source=debugrun&utm_medium=referral">Hexo中添加本地图片</a></li><li><a href="https://wangwei1237.github.io/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/">解决hexo-asset-image的图片地址错误问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 hexo 博客中插入博客，可以使用&lt;strong&gt;图床&lt;/strong&gt;和&lt;strong&gt;本地图片&lt;/strong&gt;两种方式。而图床可能由于网络原因导致加载问题，并且需要另外管理。所以，尝试使用本地的图片。&lt;/p&gt;</summary>
    
    
    
    
    <category term="blog" scheme="http://hurk.top/tags/blog/"/>
    
    <category term="hexo" scheme="http://hurk.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 搭建的博客下自定义新页面</title>
    <link href="http://hurk.top/2021/10/07/frontend-hexo-add-new-page/"/>
    <id>http://hurk.top/2021/10/07/frontend-hexo-add-new-page/</id>
    <published>2021-10-07T01:49:37.000Z</published>
    <updated>2021-10-27T12:44:54.251Z</updated>
    
    <content type="html"><![CDATA[<p>使用 hexo 和 jade 自定义博客的新页面，以 about 页为例。<br>关于我在 hexo 搭的博客里介绍如何基于 hexo 自定义新页面这件事。</p><span id="more"></span><h2 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h2><h3 id="1-1-jade"><a href="#1-1-jade" class="headerlink" title="1.1 jade"></a>1.1 jade</h3><h2 id="2-增加新页面"><a href="#2-增加新页面" class="headerlink" title="2. 增加新页面"></a>2. 增加新页面</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.manongjc.com/detail/8-tapvdvhhfcecwin.html">hexo–新建页面、修改主页</a></li><li><a href="https://www.cnblogs.com/cowboybusy/p/11146634.html">hexo–定制开发</a></li><li><a href="https://www.cnblogs.com/Mr-liyang/p/7677059.html">Jade模板引擎使用详解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 hexo 和 jade 自定义博客的新页面，以 about 页为例。&lt;br&gt;关于我在 hexo 搭的博客里介绍如何基于 hexo 自定义新页面这件事。&lt;/p&gt;</summary>
    
    
    
    
    <category term="blog" scheme="http://hurk.top/tags/blog/"/>
    
    <category term="hexo" scheme="http://hurk.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下录屏</title>
    <link href="http://hurk.top/2021/10/06/tool-vlc-screencast/"/>
    <id>http://hurk.top/2021/10/06/tool-vlc-screencast/</id>
    <published>2021-10-06T08:50:31.000Z</published>
    <updated>2021-10-06T09:23:26.583Z</updated>
    
    <content type="html"><![CDATA[<p>在 Ubuntu 下录屏。工具：</p><ol><li>VLC</li><li>Kazam</li></ol><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Ubuntu 下录屏。工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VLC&lt;/li&gt;
&lt;li&gt;Kazam&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://hurk.top/categories/Linux/"/>
    
    <category term="tool" scheme="http://hurk.top/categories/Linux/tool/"/>
    
    
    <category term="tool" scheme="http://hurk.top/tags/tool/"/>
    
    <category term="工具" scheme="http://hurk.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux 创建新用户</title>
    <link href="http://hurk.top/2021/09/22/linux-add-new-user/"/>
    <id>http://hurk.top/2021/09/22/linux-add-new-user/</id>
    <published>2021-09-22T11:26:00.000Z</published>
    <updated>2021-10-06T09:20:33.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1 常用命令"></a>1 常用命令</h2><p>创建用户：</p><ul><li><code>useradd</code></li><li><code>adduser</code></li></ul><p>区别：</p><ul><li><code>useradd</code> 需要使用参数选项指定基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。</li><li><code>adduser</code> 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。</li></ul><h2 id="2-useradd"><a href="#2-useradd" class="headerlink" title="2 useradd"></a>2 useradd</h2><p><code>useradd</code> 命令用于在 <code>Linux</code> 下创建新用户。</p><p>&lt;增加 useradd 的参数介绍&gt;</p><h2 id="3-adduser"><a href="#3-adduser" class="headerlink" title="3 adduser"></a>3 adduser</h2><p><code>adduser</code> 与 <code>useradd</code> 指令为同一指令（经由符号连结 symbolic link）。</p><p>&lt;使用介绍&gt;</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://blog.csdn.net/beitiandijun/article/details/41678251">linux用户管理（1）—创建用户（adduser和useradd）和删除用户（userdel）</a></li></ul>]]></content>
    
    
    <summary type="html">Linux 创建新用户的命令：useradd、adduser。</summary>
    
    
    
    
    <category term="Linux" scheme="http://hurk.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Golang - 在 Gin 中自定义中间件</title>
    <link href="http://hurk.top/2021/09/18/golang-add-middleware-in-gin/"/>
    <id>http://hurk.top/2021/09/18/golang-add-middleware-in-gin/</id>
    <published>2021-09-18T12:24:28.000Z</published>
    <updated>2021-10-06T09:11:40.236Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Gin 框架时，自定义中间件 middleware，以对请求做不同操作。</p><span id="more"></span><h2 id="0x01-引言"><a href="#0x01-引言" class="headerlink" title="0x01 引言"></a>0x01 引言</h2><p><a href="https://github.com/gin-gonic/gin">Gin</a> 是一个基于 Golang 的网络框架，不仅具有高性能，而且极易使用。它比另一个 Golang 的常见的 HTTP 框架 <a href="https://github.com/julienschmidt/httprouter">HttpRouter</a> 速度快了将近 40 倍。</p><p>使用 Gin，可以快速启动一个高效的 HTTP 服务。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 Gin 的实例</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册路由</span></span><br><span class="line">    <span class="comment">// GET /ping</span></span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 以 Json 格式返回数据</span></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-Gin-中的中间件"><a href="#0x02-Gin-中的中间件" class="headerlink" title="0x02 Gin 中的中间件"></a>0x02 Gin 中的中间件</h2><p>使用 <code>gin.Default()</code> 初始化的实例，已经默认使用了 2 个中间件 <code>gin.Logger()</code> 和 <code>gin.Recovery()</code>。</p><p><code>gin.New()</code> 则返回没使用任何中间件的 Gin 实例。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r1 := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// 完全空白的 gin 实例</span></span><br><span class="line">r2 := gin.New()</span><br><span class="line"><span class="comment">// Logger() 输出 gin 运行时的日志</span></span><br><span class="line">r2.Use(gin.Logger())</span><br><span class="line"><span class="comment">// 当程序 panic 时，Recovery() 自动返回网络状态码为 500 的响应</span></span><br><span class="line">r2.Use(gin.Recovery())</span><br></pre></td></tr></table></figure><h2 id="0x03-自定义中间件"><a href="#0x03-自定义中间件" class="headerlink" title="0x03 自定义中间件"></a>0x03 自定义中间件</h2><p>可以自定义中间件，根据业务要求对请求做不同处理。</p><p>自定义中间件步骤：</p><ol><li>定义一个函数来做中间件，该函数返回值为 <code>gin.HandlerFunc</code>。</li><li>在启动服务 <code>Run()</code> 前，注册该中间件。</li></ol><h3 id="gin-HandlerFunc"><a href="#gin-HandlerFunc" class="headerlink" title="gin.HandlerFunc"></a>gin.HandlerFunc</h3><p><code>gin.HandlerFunc</code> 的原型如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc defines the handler used by gin middleware as return value.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>在实际使用时，参数一般使用 gin.Context。</p><p>在 <code>gin.HandlerFunc()</code> 中，需要调用 <code>func (c *Context) Next()</code>，将请求传入中间件链的后面，以继续处理。否则，该请求的处理到这个中间件为止，后面的业务逻辑均无效。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalculateLatency() 计算该请求的处理耗时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalculateLatency</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 记录当前时间</span></span><br><span class="line">        timeBefore := time.Now()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续逻辑处理此请求</span></span><br><span class="line">        c.Next()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理完毕后，计算耗时</span></span><br><span class="line">        latency := time.Since(timeBefore)</span><br><span class="line">        log.Print(latency)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.New()</span><br><span class="line">    <span class="comment">// 注册中间件</span></span><br><span class="line">r.Use(CalculateLatency())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册路由</span></span><br><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">100</span>, <span class="string">&quot;hello, custom middleware!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务，监听 8080 端口</span></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></li><li><a href="https://github.com/gin-gonic/gin#custom-middleware">Gin custom middleware</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 Gin 框架时，自定义中间件 middleware，以对请求做不同操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://hurk.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>C++ - 实现单例模式</title>
    <link href="http://hurk.top/2021/09/02/cpp-singleton-pattern/"/>
    <id>http://hurk.top/2021/09/02/cpp-singleton-pattern/</id>
    <published>2021-09-02T13:58:21.000Z</published>
    <updated>2021-10-06T11:10:22.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>总体实现方式：将构造函数设为私有的 private，然后通过类的一个<strong>公共静态函数</strong>来生成实例。<br>并且，拷贝构造函数、移动构造函数、赋值运算符等也要设为 private（或者=delete）</p><p>几种实现方式：</p><ul><li>懒汉（非线程安全）</li><li>懒汉+互斥锁 mutex（双重检查锁模式）（线程安全）</li><li>饿汉（天生线程安全）</li><li>局部静态实例（线程安全）</li><li>pthread_once（线程安全）</li><li>memory barrier 模式（线程安全）</li><li>Atomic（线程安全）</li></ul><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h2><h3 id="2-1-懒汉"><a href="#2-1-懒汉" class="headerlink" title="2.1 懒汉"></a>2.1 懒汉</h3><p>懒汉方式，只有当用到该单例时，才初始化单例。</p><p>具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * singleton.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SINGLETON_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * singleton.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;singleton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Singleton_lazy* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-懒汉-加锁-mutex（双重检查锁模式）"><a href="#2-2-懒汉-加锁-mutex（双重检查锁模式）" class="headerlink" title="2.2 懒汉+加锁 mutex（双重检查锁模式）"></a>2.2 懒汉+加锁 mutex（双重检查锁模式）</h3><p>懒汉方式是线程不安全的，所以需要加保护措施。使用<strong>双重检查锁</strong>，可以较大限度减小锁的粒度。</p><p>双重检查锁的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双重检查锁</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;   <span class="comment">// 第一次检查</span></span><br><span class="line">        <span class="function">Lock lock</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(instance == <span class="literal">nullptr</span>)</span> </span>&#123;   <span class="comment">// 第二次检查</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * singleton.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SINGLETON_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * singleton.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;singleton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mu;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双重检查锁</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(Singleton::mu)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-饿汉"><a href="#2-3-饿汉" class="headerlink" title="2.3 饿汉"></a>2.3 饿汉</h3><p>饿汉方式在最初就生成一个单例。</p><p>由于并发情况下只是简单的“读操作”，即返回该单例的指针，所以线程安全。</p><p>具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * singleton.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SINGLETON_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * singleton.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;singleton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始就生成一个实例</span></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-局部静态实例"><a href="#2-4-局部静态实例" class="headerlink" title="2.4 局部静态实例"></a>2.4 局部静态实例</h3><p>在 C++11 后，在 getInstance() 内声明一个局部静态对象，则只会有着一个单例。并且，该静态对象会在程序结束时自动析构回收。</p><p>具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * SingleInstance.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInstance_local</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingleInstance_local &amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleInstance_local</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">SingleInstance_local</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingleInstance_local</span>(<span class="keyword">const</span> SingleInstance_local&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleInstance_local &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SingleInstance_local&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SingleInstance.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SingleInstance_local &amp; <span class="title">SingleInstance_local::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态变量</span></span><br><span class="line">    <span class="keyword">static</span> SingleInstance_local sl;</span><br><span class="line">    <span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-pthread-once"><a href="#2-5-pthread-once" class="headerlink" title="2.5 pthread_once"></a>2.5 pthread_once</h3><p>在 unix 平台的话，在不适用 C++11 的情况下，还可以通过 <code>pthread_once</code> 来实现 Singleton。</p><p>函数原型：<code>int pthread_once(pthread_once_t once_control, void (init_routine) (void));</code></p><p>具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">singleton *<span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init函数只会执行一次</span></span><br><span class="line">        <span class="built_in">pthread_once</span>(&amp;ponce_, &amp;singleton::init);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">singleton</span>();</span><br><span class="line">    <span class="built_in">singleton</span>(<span class="keyword">const</span> singleton &amp;other);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//要写成静态方法的原因：类成员函数隐含传递this指针（第一个参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> ponce_;</span><br><span class="line">    <span class="keyword">static</span> singleton *instance;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用 C++ 实现单例模式的多种方式，包括但不限于：懒汉、懒汉+双重检查锁、饿汉、局部静态实例等等方式。</summary>
    
    
    
    <category term="C++" scheme="http://hurk.top/categories/C/"/>
    
    <category term="设计模式" scheme="http://hurk.top/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="http://hurk.top/tags/C/"/>
    
    <category term="设计模式" scheme="http://hurk.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Golang - 不同字符串拼接方法 benchmark</title>
    <link href="http://hurk.top/2021/09/02/golang-benchmark-string-concat/"/>
    <id>http://hurk.top/2021/09/02/golang-benchmark-string-concat/</id>
    <published>2021-09-02T12:59:30.000Z</published>
    <updated>2021-10-06T11:34:02.978Z</updated>
    
    <content type="html"><![CDATA[<p>使用 go test，比较 Golang 中不同字符串拼接方法的性能差异（耗时和内存）。</p><span id="more"></span><h1 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1 字符串拼接"></a>1 字符串拼接</h1><p>Golang 中常见字符串拼接方法：</p><ul><li>“+” 运算符</li><li>fmt.Sprintf</li><li>strings.Join</li><li>bytes.Buffer（以及预设 buffer 容量）</li><li>string.Builder（以及预设 buffer 容量）</li></ul><h2 id="1-1-“-”-运算符"><a href="#1-1-“-”-运算符" class="headerlink" title="1.1 “+” 运算符"></a>1.1 “+” 运算符</h2><p>Go 中的 string 是不可变的，所以每次 <code>+</code> 都会生成一个新的 string，再返回。多次 <code>+</code> 就会多次分配内存和拷贝，性能消耗较大。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;&quot;</span></span><br><span class="line">str = str + <span class="string">&quot;new string&quot;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-fmt-Sprintf"><a href="#1-2-fmt-Sprintf" class="headerlink" title="1.2 fmt.Sprintf"></a>1.2 fmt.Sprintf</h2><p><code>fmt.Sprintf</code> 常用于拼接不同类型数据形成字符串。需要做类型判断等工作，损失性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;this is test string 1&quot;</span></span><br><span class="line">str3 := <span class="string">&quot;this is test string 2&quot;</span></span><br><span class="line">result := fmt.Sprintf(<span class="string">&quot;%s%s&quot;</span>, str1, str2)</span><br></pre></td></tr></table></figure><h2 id="1-3-strings-Join"><a href="#1-3-strings-Join" class="headerlink" title="1.3 strings.Join"></a>1.3 strings.Join</h2><p><code>strings.Join</code> 常用于使用分隔符拼接字符串数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strArr := []<span class="keyword">string</span>&#123;<span class="string">&quot;home&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;file&quot;</span>&#125;</span><br><span class="line">result := strings.Join(strArr, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="comment">// &quot;/home/username/file&quot;</span></span><br></pre></td></tr></table></figure><h2 id="1-4-bytes-Buffer"><a href="#1-4-bytes-Buffer" class="headerlink" title="1.4 bytes.Buffer"></a>1.4 bytes.Buffer</h2><p><code>bytes.Buffer</code> 会使用缓冲区来拼接字符串。当缓冲区容量不够时，使用一定策略扩容。<br>如果预先知道结果字符串的大小，可以使用 <code>Grow()</code> 预设缓冲区大小。</p><h2 id="1-5-string-Builder"><a href="#1-5-string-Builder" class="headerlink" title="1.5 string.Builder"></a>1.5 string.Builder</h2><h1 id="2-预设场景"><a href="#2-预设场景" class="headerlink" title="2 预设场景"></a>2 预设场景</h1><p>模拟需要多次拼接字符串的场景。</p><p>对于一条基字符串（如 <code>&quot;BaseString&quot;</code>），拼接足够多次，最后返回 string 类型的变量。</p><h1 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3 测试结果"></a>3 测试结果</h1><p><a href="https://github.com/HuIsKelvin/go-test-collection/tree/master/benchmark/string_concate">测试代码</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; go <span class="built_in">test</span> -bench=<span class="string">&quot;.&quot;</span> -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test-collection/string_concate</span><br><span class="line">cpu: Intel(R) Core(TM) i5-9400 CPU @ 2.90GHz</span><br><span class="line">BenchmarkStringPlus-6                       5118            241411 ns/op         1606811 B/op        499 allocs/op</span><br><span class="line">BenchmarkFmtSprintf-6                       3759            310479 ns/op         1625079 B/op       1500 allocs/op</span><br><span class="line">BenchmarkStringsJoin-6                      5224            244217 ns/op         1606826 B/op        500 allocs/op</span><br><span class="line">BenchmarkByteBuffer-6                     171885              6377 ns/op           25872 B/op          9 allocs/op</span><br><span class="line">BenchmarkByteBufferPreSize-6              286476              4443 ns/op           12288 B/op          2 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6                  203931              6203 ns/op           26736 B/op         14 allocs/op</span><br><span class="line">BenchmarkStringBuilderPreSize-6           436584              2880 ns/op            6144 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test-collection/string_concate       8.958s</span><br></pre></td></tr></table></figure><h1 id="4-结论分析"><a href="#4-结论分析" class="headerlink" title="4 结论分析"></a>4 结论分析</h1><p>在多次拼接字符串时，基于预设大小的 <code>strings.Builder</code> 的性能是最好的，无论是从执行速度还是占用内存的角度来说。其次性能较好的是基于预设大小的 <code>bytes.Buffer</code> 这种方法。再最后，性能从高到低为 <code>+</code>、<code>strings.Join</code> 和 <code>fmt.Sprintf</code>。</p><ul><li>在已知最终字符串长度的情况下，先给 buffer 预设大小。</li><li>将多种类型的数据拼接为字符串，则使用 <code>fmt.Sprintf</code>。</li><li>以零个或一个分隔符拼接已知的字符串数组时，使用 <code>strings.Join</code>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hermanschaaf.com/efficient-string-concatenation-in-go/">Efficient String Concatenation in Go</a></li><li><a href="https://segmentfault.com/a/1190000012978989">golang 几种字符串的连接方式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 go test，比较 Golang 中不同字符串拼接方法的性能差异（耗时和内存）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://hurk.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一个 todo list 的小 demo</title>
    <link href="http://hurk.top/2019/04/13/demo-todo-list/"/>
    <id>http://hurk.top/2019/04/13/demo-todo-list/</id>
    <published>2019-04-13T15:14:20.000Z</published>
    <updated>2021-10-06T09:22:27.117Z</updated>
    
    <content type="html"><![CDATA[<p>使用原生 JS 实现一个简单 Todo list。</p><span id="more"></span><h2 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h2><ul><li>新增待做事项</li><li>删除待做事项</li><li>搜索，并在列表中高亮检索词</li></ul><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://s2.ax1x.com/2019/04/13/ALxjlq.jpg" alt="ALxjlq.jpg"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul><li>Dom操作</li><li>Js事件监听</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>To do list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#app</span> <span class="selector-class">.app-title</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-transform</span>: capitalize;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-id">#add-to-do</span>,</span></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span><span class="selector-attr">[id=<span class="string">&quot;list&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#add-to-do</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span><span class="selector-attr">[id=<span class="string">&quot;list&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#list</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">2px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#list</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#list</span> <span class="selector-tag">span</span><span class="selector-attr">[class=<span class="string">&quot;del&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">            <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#list</span> <span class="selector-tag">span</span><span class="selector-attr">[class=<span class="string">&quot;hl&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;app-title&quot;</span>&gt;</span>to do list<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add-to-do&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;add thing to do&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> add = <span class="built_in">document</span>.getElementById(<span class="string">&quot;add-to-do&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 存储待做事项</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> items = [];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 新增待做事项</span></span></span><br><span class="line"><span class="javascript">            add.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (e.keyCode === <span class="number">13</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    removeList();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> val = add.value;</span></span><br><span class="line"><span class="javascript">                    items.push(val);</span></span><br><span class="line"><span class="javascript">                    showList(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="javascript">                    add.value = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// input输入改变时，高亮</span></span></span><br><span class="line"><span class="javascript">            add.addEventListener(<span class="string">&quot;input&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                redrawList(add.value);</span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            list.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 删除待做事项</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(e.target.className === <span class="string">&quot;del&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// var parent = e.target.parentNode;</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// var index = (parent.id.split(&quot;-&quot;))[1];</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> index = (e.target.id.split(<span class="string">&quot;-&quot;</span>))[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">                    items.splice(index, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                    redrawList(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">redrawList</span>(<span class="params">val</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                removeList();</span></span><br><span class="line"><span class="javascript">                showList(val);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">removeList</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;#list li&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> lis) &#123;</span></span><br><span class="line"><span class="javascript">                    list.removeChild(i);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">showList</span>(<span class="params">val</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (items) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> text = items[i];</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 若需要匹配val</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span>(val) &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(val, <span class="string">&#x27;g&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                            text = text.replace(reg, <span class="string">&quot;&lt;span class=&#x27;hl&#x27;&gt;&quot;</span> + val + <span class="string">&quot;&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">                        &#125;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// create li element</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> elemLi = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">                        elemLi.innerHTML = text + <span class="string">&quot;&lt;span id=&#x27;del-&quot;</span> + i+ <span class="string">&quot;&#x27; class=&#x27;del&#x27;&gt;x&lt;/span&gt;&quot;</span>;</span></span><br><span class="line"><span class="javascript">                        list.appendChild(elemLi);</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用原生 JS 实现一个简单 Todo list。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CSS - div的高度填满剩余空间</title>
    <link href="http://hurk.top/2019/04/04/div-fill-in-the-rest-zoom/"/>
    <id>http://hurk.top/2019/04/04/div-fill-in-the-rest-zoom/</id>
    <published>2019-04-04T14:15:11.000Z</published>
    <updated>2021-10-07T02:18:01.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1 描述"></a>1 描述</h2><p>使用CSS实现。<br>页面有上下两个部分，上部分定高，下部分填满窗口剩余的高度，不能出现纵向滚动条。</p><p>示例：<br><a href="https://imgchr.com/i/ARmKG6"><img src="https://s2.ax1x.com/2019/04/04/ARmKG6.jpg" alt="ARmKG6.jpg"></a><br>（只是为了看的直观，没考虑配色美观）</p><p>HTML结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 上面的部分 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span>nav<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 剩余部分 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2 具体实现"></a>2 具体实现</h2><h3 id="2-1-使用float"><a href="#2-1-使用float" class="headerlink" title="2.1 使用float"></a>2.1 使用float</h3><p>将 <code>#nav</code> 设置为 <code>float: left;</code>，再让 <code>#content</code> 的宽度为 100%。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/* 一定要设置这个 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4B5ED7</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  <span class="comment">/* width 不设置100%，也是横铺满的 */</span></span><br><span class="line">  <span class="comment">/* width: 100%; */</span> </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用absolute，再限定top和bottom"><a href="#2-2-使用absolute，再限定top和bottom" class="headerlink" title="2.2 使用absolute，再限定top和bottom"></a>2.2 使用absolute，再限定top和bottom</h3><p>使用 <code>position: absolute;</code>，再配合<code>top</code>和<code>bottom</code>，来强制定义盒模型的区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4B5ED7</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="comment">/* 距顶部距离就是 #nav 的 height */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用flex"><a href="#2-3-使用flex" class="headerlink" title="2.3 使用flex"></a>2.3 使用flex</h3><p>使用 <code>position: flex;</code>，主轴设置为纵向。<br><code>flex-grow</code> 用来指定父容器多余空间的分配比率。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/* 一定要设置这个height */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="comment">/* 一定要设置这个height */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4B5ED7</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-使用calc-和-vh"><a href="#2-4-使用calc-和-vh" class="headerlink" title="2.4 使用calc()和 vh"></a>2.4 使用calc()和 vh</h2><p><code>calc()</code> 函数是<code>CSS</code>中用于动态计算长度值。<br><code>vh</code> 是相对于视口的高度，视口被均分为100单位，一个单位为<code>1vh</code>。<br>两个都是CSS3的属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4B5ED7</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">40px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">用CSS实现div的高度填满剩余空间</summary>
    
    
    
    
    <category term="CSS" scheme="http://hurk.top/tags/CSS/"/>
    
    <category term="front-end" scheme="http://hurk.top/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Duplicate repetitive elements in array</title>
    <link href="http://hurk.top/2019/04/03/duplicate-repetitive-elements-in-array/"/>
    <id>http://hurk.top/2019/04/03/duplicate-repetitive-elements-in-array/</id>
    <published>2019-04-03T14:36:13.000Z</published>
    <updated>2021-09-02T13:31:49.025Z</updated>
    
    <content type="html"><![CDATA[<p>去除数组中重复元素</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>去除数组中重复元素，并得到被删除元素的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">[1, 2, 1, 5, 2, 6, 1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">[1, 2, 1]</span><br><span class="line"></span><br><span class="line">// 被删除的数组中有重复值</span><br></pre></td></tr></table></figure><h1 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 被删除元素的数组</span></span><br><span class="line"><span class="keyword">var</span> removed = [];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.indexOf(e) !== index) &#123;</span><br><span class="line">    arr.splice(index, <span class="number">1</span>);</span><br><span class="line">    removed.push(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;去除数组中重复元素&lt;/p&gt;
&lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;p&gt;去除数组中重复元素，并得到被删除元素的数组。&lt;/p&gt;
&lt;figure class=&quot;highlight p</summary>
      
    
    
    
    
    <category term="算法" scheme="http://hurk.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++ —函数</title>
    <link href="http://hurk.top/2019/04/01/cplusplus-2-function/"/>
    <id>http://hurk.top/2019/04/01/cplusplus-2-function/</id>
    <published>2019-04-01T07:30:25.000Z</published>
    <updated>2021-09-02T13:31:49.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>每个 C++ 程序都至少有一个函数，即主函数<code>main()</code>。</p><p><strong>函数定义</strong>（function definition）即函数本身，由<strong>函数首部</strong>（function heading）和<strong>函数体</strong>（Function body）组成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名（形式参数列表）  <span class="comment">// 函数首部</span></span><br><span class="line">&#123;</span><br><span class="line">  C++语句                       <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h2><p>分为两种。</p><p><strong>无返回值函数</strong>，返回值类型为<code>void</code>；</p><p><strong>带返回值函数</strong>， 函数体中必有<code>return语句</code>，返回值类型为<code>return</code>后表达式的值的类型。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>除了<code>main</code>函数，其他所有函数名都是用户自定义的标识符。</p><h2 id="形式参数表"><a href="#形式参数表" class="headerlink" title="形式参数表"></a>形式参数表</h2><p>函数可以有形式参数表，也可以没有。<strong>形式参数肯定是变量。</strong></p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>是函数的实现部分，由<code>&#123;&#125;</code>和<code>c++</code>语句组成。</p><p>对于<strong>带返回值函数</strong>， 函数体中必有<code>return语句</code>。对于<strong>无返回值函数</strong>，函数体没有<code>return</code>语句，或者有<code>return;</code>；</p><blockquote><p>若return 后面的表达式类型与函数首部指定的返回值类型不同，则进行隐式类型转换。</p></blockquote><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><p>除了main函数，其他所有函数名都是用户自定义的标识符。<br>在c++中，所有标识符都应“先声明再使用”，否则编译器无法识别，从而无法继续编译。<br><strong>函数原型的作用</strong>就是为编译器提供相关函数的信息，令编译器在编译后面的函数调用语句时可以成功。</p><p>函数原型与函数头部相似。</p><p>函数原型的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参<span class="number">1</span>数据类型, 形参<span class="number">2</span>数据类型, ...);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getName</span><span class="params">()</span></span>;              <span class="comment">// 无形参的函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mulSqrt</span><span class="params">( <span class="keyword">int</span> , <span class="keyword">int</span> )</span></span>;  <span class="comment">// 无形参名</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mulSqrt</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;  <span class="comment">// 有形参名</span></span><br></pre></td></tr></table></figure><p>函数原型一般放在<strong>程序开头</strong>，起全局作用。其后的函数定义和函数调用的顺序先后，不会影响编译。</p><p>若函数定义在函数调用之前，则可以省略函数原型。</p><p>函数原型也称为，函数声明。</p><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>实际上，程序中各个函数定义的位置可以按任意顺序排列。<br>编译时，编译器按照位置上的前后顺序进行编译。<br>但在执行时，整个控制流程总是从 <code>main</code> 函数的第一条语句开始，按逻辑顺序往下执行。当遇到函数调用时，控制权就进入被调用函数的第一条语句，按逻辑顺序往下执行，直到最后一条语句，然后控制权就返回到函数调用后的语句上。</p><p>一般来说，整个程序的执行从 <code>main</code> 函数开始，也在 <code>main</code> 函数中结束。</p><blockquote><p>在C++程序中，main函数与一般函数的不同在于：<br>一般函数都是被别的函数调用，而main函数是被操作系统调用。这是因为任何用户程序都在操作系统的管理下运行，因此main函数中的返回值是返回给操作系统的。</p></blockquote><p>从程序员角度， <code>main</code> 函数中一般用 <code>return 0;</code> 表示程序顺利完成预定任务；而用 <code>return 1;</code> 表示程序由于遇到了某种情况而没有顺利完成任务。</p><p>函数调用的语法形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数名（实参列表）</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 有形参时 ---</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;    <span class="comment">// 函数首部</span></span><br><span class="line"><span class="built_in">sqrt</span>(x1, x2);                 <span class="comment">// 函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 无形参时 ---</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span></span>;     <span class="comment">// 函数首部</span></span><br><span class="line"><span class="built_in">printLine</span>();          <span class="comment">// 函数调用</span></span><br></pre></td></tr></table></figure><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>在C++中，形参分为<strong>值形参</strong>（value parameter）和<strong>引用形参</strong>（reference parameter）。<br>声明形参时，在数据类型后加<code>&amp;</code>，则这个形参时引用形参；否则为值形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span>&amp; param1,    <span class="comment">// param1 是引用形参</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> param2)</span></span>;    <span class="comment">// param1 是值形参</span></span><br></pre></td></tr></table></figure><h2 id="值形参"><a href="#值形参" class="headerlink" title="值形参"></a>值形参</h2><p>值形参接受实参的值，其对应的实参可以是任何具有值得项目，如常量、变量和表达式。</p><ol><li>实参的数据类型，应与相应位置形参数据类型一致，否则隐式类型转换。</li><li>值形参时，实参与其对应的形参是两个不同的数据项。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main&#123;</span><br><span class="line">  <span class="keyword">int</span> x1, x2, result;</span><br><span class="line">  result = <span class="built_in">add</span>(x1, x2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>main函数中的实参 x1 与 add 函数中的 x 是不同的数据项，两者占据不同内存块。<br>在函数调用时，x1 的值传递给 x， <strong>然后两者就没关系了</strong>。</li><li>判断两个变量是否为同一变量，是看它们是否对应同一块内存。</li></ol><h2 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h2><p>引用形参接收的是实参变量的地址空间，则<strong>引用形参与实参是同一变量</strong>。</p><p><strong>引用形参所对应的实参一定是变量</strong>。因为引用形参本身是一个变量，而实参与它对应同一内存块，因此也一定是一个变量。</p><p>对于引用形参，函数原型中一定注意有 <code>&amp;</code> 这个符号，否则会编译错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refPara</span><span class="params">(<span class="keyword">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="标识符作用域"><a href="#标识符作用域" class="headerlink" title="标识符作用域"></a>标识符作用域</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>某标识符的<strong>作用域</strong>（scope）就是：在程序代码中可合法引用（使用）该标识符的区域。</p><h3 id="局部作用域（local-scope）"><a href="#局部作用域（local-scope）" class="headerlink" title="局部作用域（local scope）"></a>局部作用域（local scope）</h3><p>在块<code>&#123;&#125;</code>中声明的标识符，起作用域就是从声明处到该块结尾。</p><h3 id="全局作用域（global-scope）"><a href="#全局作用域（global-scope）" class="headerlink" title="全局作用域（global scope）"></a>全局作用域（global scope）</h3><p>在所有块（包括函数、类和控制结构中的块）以外声明的标识符，其作用域是从声明处到文件结尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14</span>;    <span class="comment">// 全局常量</span></span><br><span class="line"><span class="keyword">int</span> radius = <span class="number">5</span>;           <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量的生命期"><a href="#变量的生命期" class="headerlink" title="变量的生命期"></a>变量的生命期</h1><p>变量的<strong>生命期</strong>（lifetime）就是：在程序执行过程中，变量实际占据内存空间的时间段。</p><p>从生命期角度来看，C++的变量分为具有<strong>局部生命期</strong>的变量和具有<strong>全局生命期</strong>的变量。</p><p>变量声明的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[存储类型] 数据类型 变量名 [= 初值]</span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">static</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">float</span> radius = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><p>变量的存储类型：<br>| 标识符          | 意义                    |<br>| ———— | ——————— |<br>| auto         | 在动态存储区分配存储单元          |<br>| register     | 在CPU的寄存器中分配存储单元。      |<br>| static       | 在静态存储区分配存储单元。         |<br>| extern       | 声明外部变量。               |<br>| mutable      | 仅适用于类的对象，允许对象的成员替代常量。 |<br>| thread_local | 变量仅可在它在其上创建的线程上访问     |</p><ul><li>auto 和 register 只能用于局部变量。</li><li>auto，register 和 static 只能用于变量的定义（即定义性声明）。</li><li>extern 既可以用于变量的定义性声明，又可用于变量的引用性声明，被声明的变量称为<strong>外部变量</strong>（extern variable）。</li></ul><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。</p><p>较少用。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>通常，声明时未加上 static 修饰符的局部变量具有局部生命期，称为<strong>自动变量</strong>。自动变量在进入声明该变量的块时被创建，在离开该块时被撤销。若多次进入和离开该块，则自动变量会多次被创建和撤销。</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>在程序运行期间，静态变量只进行一次初始化。静态变量的初始化在执行 main 函数之前。</p><p>静态变量具有全局生命期，在程序开始执行时创建，在程序运行结束时撤销，其生命期与程序执行时间等长。</p><h4 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h4><p>在声明时，在全局变量前加上<code>static</code>。</p><blockquote><p>全局变量本身有全局生命期，因此定义全局变量时加 static 的作用是：限制该全局变量不会被别的文件引用。</p></blockquote><blockquote><p>不提倡使用全局变量，因此静态全局变量用的不多。</p></blockquote><h4 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h4><p>在声明时，在局部变量前加上<code>static</code>。</p><blockquote><p>局部静态变量是局部变量。虽然该变量具有全局变量生命期，但是在其作用域之外是无法访问它的。</p></blockquote><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>。。。</p><h3 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h3><p>定义性声明：带初始化表达式的外部变量声明；引用性声明：不带初始化表达式~。</p><blockquote><p>局部变量默认为 auto（旧版），全局变量默认为 extern。</p></blockquote><h1 id="预处理指示"><a href="#预处理指示" class="headerlink" title="预处理指示"></a>预处理指示</h1><p>。。。</p><h1 id="函数的接口设计和注释"><a href="#函数的接口设计和注释" class="headerlink" title="函数的接口设计和注释"></a>函数的接口设计和注释</h1><p>。。。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归的特点：</p><ul><li>有两个过程组成：追溯和回归。</li><li>其每一步的计算方案可用这个方案的一个更小版本或其基本条件来实现。</li></ul><blockquote><p>正确的递归程序必须是可终止的！<br>递归程序必须至少有一个基本条件，来确保它们最终会达到某个基本分支。</p></blockquote><p>例子，计算 x 的 k 次方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用递归方式求 x 的 k 次方</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 基, 幂次和结果</span></span><br><span class="line">  <span class="keyword">int</span> base, exp, result;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;enter the base and the exponent&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; base &gt;&gt; exp;</span><br><span class="line"></span><br><span class="line">  result = <span class="built_in">power</span>(base, exp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 终止条件</span></span><br><span class="line">  <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 x 的 k-1 次方</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">power</span>(x, k<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C++ 函数</summary>
    
    
    
    
    <category term="C++" scheme="http://hurk.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ —入门基础</title>
    <link href="http://hurk.top/2019/04/01/cplusplus-1-base-knowledge/"/>
    <id>http://hurk.top/2019/04/01/cplusplus-1-base-knowledge/</id>
    <published>2019-04-01T07:14:05.000Z</published>
    <updated>2021-09-02T13:31:48.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>待更新！</p><h1 id="语句与基本控制结构"><a href="#语句与基本控制结构" class="headerlink" title="语句与基本控制结构"></a>语句与基本控制结构</h1><p>待更新！</p>]]></content>
    
    
    <summary type="html">C++入门</summary>
    
    
    
    
    <category term="C++" scheme="http://hurk.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSS-鼠标hover某元素，控制另一个元素显示</title>
    <link href="http://hurk.top/2019/03/30/frontend-hover-item-show-another-item/"/>
    <id>http://hurk.top/2019/03/30/frontend-hover-item-show-another-item/</id>
    <published>2019-03-30T02:36:27.000Z</published>
    <updated>2021-09-22T11:44:28.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1 描述"></a>1 描述</h2><p>页面上有一个元素A，和另一个元素B。当鼠标悬浮在元素A上时，元素B同时显示。</p><p>例子：<br><a href="https://imgchr.com/i/ABoRxK"><img src="https://s2.ax1x.com/2019/03/30/ABoRxK.md.gif" alt="ABoRxK.md.gif"></a></p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h2><p>例子页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.box-a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.box-b</span> &#123;</span><br><span class="line">  <span class="comment">/* 默认不显示 */</span></span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 左边距离即 box-a 的width */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: antiquewhite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1-CSS实现"><a href="#2-1-CSS实现" class="headerlink" title="2.1 CSS实现"></a>2.1 CSS实现</h3><p>使用CSS的伪类和选择器来实现。</p><p>将元素B作元素A的兄弟元素或子元素，用元素A的hover状态作选择器的限制部分，控制元素B的<code>display: block;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 style 中加入这一个 */</span></span><br><span class="line"><span class="selector-class">.box-a</span><span class="selector-pseudo">:hover</span> ~ <span class="selector-class">.box-b</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2Javascript事件监听来实现"><a href="#2-2Javascript事件监听来实现" class="headerlink" title="2.2Javascript事件监听来实现"></a>2.2Javascript事件监听来实现</h3><p>通过元素A监听事件 <code>mouseover</code> 和 <code>mouseout</code>，来控制元素B的显示和隐藏。</p><p>但这种办法稍显麻烦，每次都要监听两个事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boxA = (<span class="built_in">document</span>.getElementByClassName(<span class="string">&quot;box-a&quot;</span>))[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> boxB = (<span class="built_in">document</span>.getElementByClassName(<span class="string">&quot;box-b&quot;</span>))[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当鼠标移入元素A时</span></span><br><span class="line">boxA.addEventListener(<span class="string">&quot;mouseover&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  boxB.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 当鼠标移出元素A时</span></span><br><span class="line">boxA.addEventListener(<span class="string">&quot;mouseout&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  boxB.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><a href="https://imgchr.com/i/AB754A"><img src="https://s2.ax1x.com/2019/03/30/AB754A.md.gif" alt="AB754A.md.gif"></a></p>]]></content>
    
    
    <summary type="html">hover一个元素，另一个元素也显示</summary>
    
    
    
    
    <category term="CSS" scheme="http://hurk.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-简介</title>
    <link href="http://hurk.top/2019/03/24/javascript-1-introduction/"/>
    <id>http://hurk.top/2019/03/24/javascript-1-introduction/</id>
    <published>2019-03-24T11:50:37.000Z</published>
    <updated>2021-09-02T13:31:49.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript-简史"><a href="#Javascript-简史" class="headerlink" title="Javascript 简史"></a>Javascript 简史</h1><p>早期的网页，表单验证必须把表单数据发送到服务器端，才能确定用户是否没有填写某个必填域，是否输入了无效的值。当年的网速很慢，为完成简单的表单验证而频繁地与服务器交换数据，只会加重用户的负担。</p><p>由此诞生了JavaScript，它主要目的是处理以前由服务器端语言（如 Perl）负责的一些输入验证操作。JavaScript的最初名字叫 LiveScript，Netscape 公司为了搭上媒体热炒Java的顺风车，临时把 LiveScript 改名为 JavaScript。</p><h1 id="Javascript-实现"><a href="#Javascript-实现" class="headerlink" title="Javascript 实现"></a>Javascript 实现</h1><p>虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMA-262 中规定的要多得多。</p><p>一个完整的 Javascript 由以下<strong>三部分组成</strong>：</p><ul><li>核心(ECMAScript)</li><li>文档对象模型(DOM)</li><li>浏览器对象模型(BOM)</li></ul><h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>由 ECMA-262 定义的ECMAScript与 Web浏览器没有依赖关系。ECMA-262 定义的只是这门语言的基础，而在此基础之上可以构建更完善的脚本语言。我们常见的 Web 浏览器只是 ECMAScript 实现可能的<strong>宿主环境之一</strong>，其他宿主环境包括 Node（一种服务端 JavaScript平台）和 Adobe Flash。</p><p>宿主环境不仅提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展——如 DOM，则利用 ECMAScript的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。</p><p>ECMA-262 标准规定了这门语言的下列组成部分：</p><ul><li>语法 </li><li>类型 </li><li>语句 </li><li>关键字 </li><li>保留字 </li><li>操作符 </li><li>对象</li></ul><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型（DOM，Document Object Model）DOM把整个页面映射为一个多层节点结构。HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。</p><p>通过 DOM 创建的这个表示文档的树形图，开发人员获得了控制页面内容和结构的主动权。借助 DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。</p><p>一个简单的 HTML 页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该 HTML 页面对应的 DOM 树：<br><img src="https://s2.ax1x.com/2019/02/16/krjmFI.jpg" alt="DOM 树"></p><blockquote><p>DOM并不只是针对 JavaScript的，很多别的语言也都实现了DOM。<br>不过，在 Web 浏览器中，基于 ECMAScript 实现的 DOM 的确已经成为 JavaScript 这 门语言的一个重要组成部分。</p></blockquote><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>开发人员使用BOM（BOM，Browser Object Model）可以控制浏览器显示的页面以外的部分。</p><p>而BOM真正与众不同的地方（也是经常会导致问题的地方），还是它作为 JavaScript 实现的一部分但却没有相关的标准。这个问题在 HTML5 中得到了解决，HTML5 致力于把很多 BOM 功能写入正式规范。有了 HTML5，BOM 实现的细节有望朝着兼容性越来越高的方向发展。</p><p>从根本上讲，BOM只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。下面就是一些这样的扩展： </p><ul><li>弹出新浏览器窗口的功能</li><li>移动、缩放和关闭浏览器窗口的功能</li><li>提供浏览器详细信息的 navigator 对象</li><li>提供浏览器所加载页面的详细信息的 location 对象</li><li>提供用户显示器分辨率详细信息的 screen 对象</li><li>对 cookies 的支持</li><li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li></ul><hr/><p>参考资料：</p><ul><li>《JavaScript 高级程序设计》</li></ul>]]></content>
    
    
    <summary type="html">JavaScript概要</summary>
    
    
    
    
    <category term="JavaScript" scheme="http://hurk.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue开发项目中遇到的坑</title>
    <link href="http://hurk.top/2019/03/08/problems-in-using-Vue/"/>
    <id>http://hurk.top/2019/03/08/problems-in-using-Vue/</id>
    <published>2019-03-08T00:06:09.000Z</published>
    <updated>2021-09-02T13:31:49.051Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用 Vue-cli 3 开发项目，于是记录下开发过程中遇到的坑。便于下次遇到相同坑时，能快速找到解决方法。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="npm-run-build-后，部署网页到服务器，出现404错误"><a href="#npm-run-build-后，部署网页到服务器，出现404错误" class="headerlink" title="npm run build 后，部署网页到服务器，出现404错误"></a>npm run build 后，部署网页到服务器，出现404错误</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为 vue-cli-3 默认打包后的项目放在域名的根目录，使用绝对路径来引用资源，则在index.html中引用资源的目录的<code>src</code>开头都为<code>&quot;/&quot;</code>.</p><p>vue-cli-3 官方文档在 <a href="https://cli.vuejs.org/zh/config/#publicpath">publicPath</a> 的说明：</p><blockquote><p>默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 <code>https://www.my-app.com/</code>。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 <code>https://www.my-app.com/my-app/</code>，则设置 publicPath 为 <code>/my-app/</code>。<br>这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘./‘)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在 vue.config.js 中，修改以下语句，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 使用相对路径引用 js、css 等资源</span></span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&quot;./&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本地开发跨域问题"><a href="#本地开发跨域问题" class="headerlink" title="本地开发跨域问题"></a>本地开发跨域问题</h2><p>在本地开发请求后端服务器接口的时候，一般都需要跨域。如果用vue-cli3搭建的项目，可以在根目录的 <code>vue.config.js</code> 文件中，修改 <code>proxy</code> 或 <code>proxyTable</code> 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://yoururl.com&#x27;</span>,  <span class="comment">// 填入你实际的后端服务器接口</span></span><br><span class="line">                <span class="attr">ws</span>: <span class="literal">true</span>,  </span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在请求时，就会将 <code>/api/posts/1</code> 请求代理到 <code>http://yoururl.com/posts/1</code>。</p><h2 id="在360浏览器上，不能正常使用URLSearchParams"><a href="#在360浏览器上，不能正常使用URLSearchParams" class="headerlink" title="在360浏览器上，不能正常使用URLSearchParams"></a>在360浏览器上，不能正常使用URLSearchParams</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>开发的网页中，有一个检索框，输入检索词并按回车后，就会将检索词传回后端进行检索。然而在360浏览器中，按回车后没反应，报错显示<code>URLSearchParams() is not defined</code>.</p><p>输入检索词后，按回车就会调用<code>search_query()</code>方法。在<code>search_query()</code>方法中，会使用<code>URLSearchParams</code>处理query，然后用<code>axios</code>的<code>post()</code>发送，然后query传给后端，再跳转到检索结果页面。</p><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p><code>URLSearchParams</code>在特定浏览器（如360浏览器）中不被兼容。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>在项目中安装 url-search-params-polyfill，在main.js中引入URLSearchParams 的类，之后可以按照正常操作使用 URLSearchParams。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i --save url-search-params-polyfill</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">import &quot;url-search-params-polyfill&quot;</span><br></pre></td></tr></table></figure><h2 id="待更新…"><a href="#待更新…" class="headerlink" title="待更新…"></a>待更新…</h2>]]></content>
    
    
    <summary type="html">记录在使用Vue的过程中遇到的问题</summary>
    
    
    
    
    <category term="Vue" scheme="http://hurk.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Apache —（一）在Win10上安装部署Apache Http Server</title>
    <link href="http://hurk.top/2019/02/03/Apache-1-installization/"/>
    <id>http://hurk.top/2019/02/03/Apache-1-installization/</id>
    <published>2019-02-03T03:30:18.000Z</published>
    <updated>2021-09-02T13:31:48.966Z</updated>
    
    <content type="html"><![CDATA[<p>在 Windows10 上安装配置 <a href="http://httpd.apache.org/download.cgi">Apache服务器</a>。<br>因为最近做的项目放在云服务器（linux），到时用 <a href="https://cn.vuejs.org/">Vue</a> 写的前端要部署在服务器的apache上，就想先在自己电脑上玩一玩apache。</p><h2 id="下载-Apache"><a href="#下载-Apache" class="headerlink" title="下载 Apache"></a>下载 Apache</h2><p>到官网下载页面 <a href="http://httpd.apache.org/download.cgi">http://httpd.apache.org/download.cgi</a> 下载安装包.</p><p>点下图红框处，下载windows的版本。<br><a href="https://s2.ax1x.com/2019/02/03/kGueqH.png"><img src="https://s2.ax1x.com/2019/02/03/kGueqH.png" alt="kGueqH.png"></a></p><p>下图的大致意思是apache本身不提供已编译的安装包，只提供源码，如果你自己无法编译，可以选择下面这些官方推荐的第三方提供编译的网站。其中后两个是有名的wamp以及xampp集成环境，如果只想下载apache可以选择前三个网站。<br>这里我下载第一种。<br><a href="https://s2.ax1x.com/2019/02/03/kGulJP.png"><img src="https://s2.ax1x.com/2019/02/03/kGulJP.png" alt="kGulJP.png"></a></p><p>然后根据自己电脑选择32位版本还是64位版本。</p><h2 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h2><p>解压压缩包</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
    <summary type="html">Apache 简单尝试，下载安装</summary>
    
    
    
    
    <category term="服务器" scheme="http://hurk.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Apache" scheme="http://hurk.top/tags/Apache/"/>
    
  </entry>
  
</feed>
