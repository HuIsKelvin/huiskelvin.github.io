<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Golang - 不同字符串拼接方法 benchmark · Kelvin's blog</title><meta name="description" content="Golang - 不同字符串拼接方法 benchmark - HuIsKelvin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://huiskelvin.github.io/atom.xml" title="Kelvin's blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Kelvin's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/huiskelvin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Golang - 不同字符串拼接方法 benchmark</h1><div class="post-info">Sep 2, 2021</div><div class="post-content"><h1 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1 字符串拼接"></a>1 字符串拼接</h1><p>Golang 中常见字符串拼接方法：</p>
<ul>
<li>“+” 运算符</li>
<li>fmt.Sprintf</li>
<li>strings.Join</li>
<li>bytes.Buffer（以及预设 buffer 容量）</li>
<li>string.Builder（以及预设 buffer 容量）</li>
</ul>
<h2 id="1-1-“-”-运算符"><a href="#1-1-“-”-运算符" class="headerlink" title="1.1 “+” 运算符"></a>1.1 “+” 运算符</h2><p>Go 中的 string 是不可变的，所以每次 <code>+</code> 都会生成一个新的 string，再返回。多次 <code>+</code> 就会多次分配内存和拷贝，性能消耗较大。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;&quot;</span></span><br><span class="line">str = str + <span class="string">&quot;new string&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-fmt-Sprintf"><a href="#1-2-fmt-Sprintf" class="headerlink" title="1.2 fmt.Sprintf"></a>1.2 fmt.Sprintf</h2><p><code>fmt.Sprintf</code> 常用于拼接不同类型数据形成字符串。需要做类型判断等工作，损失性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;this is test string 1&quot;</span></span><br><span class="line">str3 := <span class="string">&quot;this is test string 2&quot;</span></span><br><span class="line">result := fmt.Sprintf(<span class="string">&quot;%s%s&quot;</span>, str1, str2)</span><br></pre></td></tr></table></figure>

<h2 id="1-3-strings-Join"><a href="#1-3-strings-Join" class="headerlink" title="1.3 strings.Join"></a>1.3 strings.Join</h2><p><code>strings.Join</code> 常用于使用分隔符拼接字符串数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strArr := []<span class="keyword">string</span>&#123;<span class="string">&quot;home&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;file&quot;</span>&#125;</span><br><span class="line">result := strings.Join(strArr, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="comment">// &quot;/home/username/file&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-bytes-Buffer"><a href="#1-4-bytes-Buffer" class="headerlink" title="1.4 bytes.Buffer"></a>1.4 bytes.Buffer</h2><p><code>bytes.Buffer</code> 会使用缓冲区来拼接字符串。当缓冲区容量不够时，使用一定策略扩容。<br>如果预先知道结果字符串的大小，可以使用 <code>Grow()</code> 预设缓冲区大小。</p>
<h2 id="1-5-string-Builder"><a href="#1-5-string-Builder" class="headerlink" title="1.5 string.Builder"></a>1.5 string.Builder</h2><h1 id="2-预设场景"><a href="#2-预设场景" class="headerlink" title="2 预设场景"></a>2 预设场景</h1><p>模拟需要多次拼接字符串的场景。</p>
<p>对于一条基字符串（如 <code>&quot;BaseString&quot;</code>），拼接足够多次，最后返回 string 类型的变量。</p>
<h1 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3 测试结果"></a>3 测试结果</h1><p><a target="_blank" rel="noopener" href="https://github.com/HuIsKelvin/go-test-collection/tree/master/benchmark/string_concate">测试代码</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; go <span class="built_in">test</span> -bench=<span class="string">&quot;.&quot;</span> -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test-collection/string_concate</span><br><span class="line">cpu: Intel(R) Core(TM) i5-9400 CPU @ 2.90GHz</span><br><span class="line">BenchmarkStringPlus-6                       5118            241411 ns/op         1606811 B/op        499 allocs/op</span><br><span class="line">BenchmarkFmtSprintf-6                       3759            310479 ns/op         1625079 B/op       1500 allocs/op</span><br><span class="line">BenchmarkStringsJoin-6                      5224            244217 ns/op         1606826 B/op        500 allocs/op</span><br><span class="line">BenchmarkByteBuffer-6                     171885              6377 ns/op           25872 B/op          9 allocs/op</span><br><span class="line">BenchmarkByteBufferPreSize-6              286476              4443 ns/op           12288 B/op          2 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6                  203931              6203 ns/op           26736 B/op         14 allocs/op</span><br><span class="line">BenchmarkStringBuilderPreSize-6           436584              2880 ns/op            6144 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test-collection/string_concate       8.958s</span><br></pre></td></tr></table></figure>

<h1 id="4-结论分析"><a href="#4-结论分析" class="headerlink" title="4 结论分析"></a>4 结论分析</h1><p>在多次拼接字符串时，基于预设大小的 <code>strings.Builder</code> 的性能是最好的，无论是从执行速度还是占用内存的角度来说。其次性能较好的是基于预设大小的 <code>bytes.Buffer</code> 这种方法。再最后，性能从高到低为 <code>+</code>、<code>strings.Join</code> 和 <code>fmt.Sprintf</code>。</p>
<ul>
<li>在已知最终字符串长度的情况下，先给 buffer 预设大小。</li>
<li>将多种类型的数据拼接为字符串，则使用 <code>fmt.Sprintf</code>。</li>
<li>以零个或一个分隔符拼接已知的字符串数组时，使用 <code>strings.Join</code>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://hermanschaaf.com/efficient-string-concatenation-in-go/">Efficient String Concatenation in Go</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012978989">golang 几种字符串的连接方式</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2021/09/02/cpp-singleton-pattern/" class="prev">上一篇</a><a href="/2019/04/13/demo-todo-list/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://huiskelvin.github.io">HuIsKelvin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>