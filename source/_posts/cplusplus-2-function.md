---
title: C++ —函数
date: 2019-04-01 15:30:25
tags:
  - C++
description: C++ 函数
---

# 函数定义

每个 C++ 程序都至少有一个函数，即主函数`main()`。

**函数定义**（function definition）即函数本身，由**函数首部**（function heading）和**函数体**（Function body）组成

```c++
返回值类型 函数名（形式参数列表）  // 函数首部
{
  C++语句                       // 函数体
}

// 实例
void myFunction(int x, int y) {
  int result = x + y;
  return result;
} 
```

## 返回值类型

分为两种。

**无返回值函数**，返回值类型为`void`；

**带返回值函数**， 函数体中必有`return语句`，返回值类型为`return`后表达式的值的类型。

## 函数名

除了`main`函数，其他所有函数名都是用户自定义的标识符。

## 形式参数表

函数可以有形式参数表，也可以没有。**形式参数肯定是变量。**

## 函数体

是函数的实现部分，由`{}`和`c++`语句组成。

对于**带返回值函数**， 函数体中必有`return语句`。对于**无返回值函数**，函数体没有`return`语句，或者有`return;`；

>若return 后面的表达式类型与函数首部指定的返回值类型不同，则进行隐式类型转换。

# 函数原型

除了main函数，其他所有函数名都是用户自定义的标识符。
在c++中，所有标识符都应“先声明再使用”，否则编译器无法识别，从而无法继续编译。
**函数原型的作用**就是为编译器提供相关函数的信息，令编译器在编译后面的函数调用语句时可以成功。

函数原型与函数头部相似。

函数原型的格式：
```c++
返回值类型 函数名(形参1数据类型, 形参2数据类型, ...);

double getName();              // 无形参的函数原型
double mulSqrt( int , int );  // 无形参名
double mulSqrt( int x, int y);  // 有形参名
```

函数原型一般放在**程序开头**，起全局作用。其后的函数定义和函数调用的顺序先后，不会影响编译。

若函数定义在函数调用之前，则可以省略函数原型。

函数原型也称为，函数声明。

# 函数调用

实际上，程序中各个函数定义的位置可以按任意顺序排列。
编译时，编译器按照位置上的前后顺序进行编译。
但在执行时，整个控制流程总是从 `main` 函数的第一条语句开始，按逻辑顺序往下执行。当遇到函数调用时，控制权就进入被调用函数的第一条语句，按逻辑顺序往下执行，直到最后一条语句，然后控制权就返回到函数调用后的语句上。

一般来说，整个程序的执行从 `main` 函数开始，也在 `main` 函数中结束。

>在C++程序中，main函数与一般函数的不同在于：
>一般函数都是被别的函数调用，而main函数是被操作系统调用。这是因为任何用户程序都在操作系统的管理下运行，因此main函数中的返回值是返回给操作系统的。

从程序员角度， `main` 函数中一般用 `return 0;` 表示程序顺利完成预定任务；而用 `return 1;` 表示程序由于遇到了某种情况而没有顺利完成任务。

函数调用的语法形式：
```c++
函数名（实参列表）

// --- 有形参时 ---
double sqrt(int x, int y);    // 函数首部
sqrt(x1, x2);                 // 函数调用

// --- 无形参时 ---
void printLine();     // 函数首部
printLine();          // 函数调用
```

# 参数传递

在C++中，形参分为**值形参**（value parameter）和**引用形参**（reference parameter）。
声明形参时，在数据类型后加`&`，则这个形参时引用形参；否则为值形参。

```c++
void f( int& param1,    // param1 是引用形参
        int param2);    // param1 是值形参
```

## 值形参

值形参接受实参的值，其对应的实参可以是任何具有值得项目，如常量、变量和表达式。

1. 实参的数据类型，应与相应位置形参数据类型一致，否则隐式类型转换。
2. 值形参时，实参与其对应的形参是两个不同的数据项。
   ```c++
   int add(int x, int y);

   void main{
     int x1, x2, result;
     result = add(x1, x2);

     return 0;
   }
   ```
   main函数中的实参 x1 与 add 函数中的 x 是不同的数据项，两者占据不同内存块。
   在函数调用时，x1 的值传递给 x， **然后两者就没关系了**。
3. 判断两个变量是否为同一变量，是看它们是否对应同一块内存。

## 引用形参

引用形参接收的是实参变量的地址空间，则**引用形参与实参是同一变量**。

**引用形参所对应的实参一定是变量**。因为引用形参本身是一个变量，而实参与它对应同一内存块，因此也一定是一个变量。

对于引用形参，函数原型中一定注意有 `&` 这个符号，否则会编译错误。
```c
void refPara(int&);
```

# 标识符作用域

## 作用域

某标识符的**作用域**（scope）就是：在程序代码中可合法引用（使用）该标识符的区域。

### 局部作用域（local scope）

在块`{}`中声明的标识符，起作用域就是从声明处到该块结尾。

### 全局作用域（global scope）

在所有块（包括函数、类和控制结构中的块）以外声明的标识符，其作用域是从声明处到文件结尾。

```c++
const float PI = 3.14;    // 全局常量
int radius = 5;           // 全局变量

int main() {
  ...
  
  return 0;
}
```

# 变量的生命期

变量的**生命期**（lifetime）就是：在程序执行过程中，变量实际占据内存空间的时间段。

从生命期角度来看，C++的变量分为具有**局部生命期**的变量和具有**全局生命期**的变量。

变量声明的形式：

```c
[存储类型] 数据类型 变量名 [= 初值]
// example
static PI = 3.14;
float radius = 5.0;
```

变量的存储类型：
| 标识符          | 意义                    |
| ------------ | --------------------- |
| auto         | 在动态存储区分配存储单元          |
| register     | 在CPU的寄存器中分配存储单元。      |
| static       | 在静态存储区分配存储单元。         |
| extern       | 声明外部变量。               |
| mutable      | 仅适用于类的对象，允许对象的成员替代常量。 |
| thread_local | 变量仅可在它在其上创建的线程上访问     |

- auto 和 register 只能用于局部变量。
- auto，register 和 static 只能用于变量的定义（即定义性声明）。
- extern 既可以用于变量的定义性声明，又可用于变量的引用性声明，被声明的变量称为**外部变量**（extern variable）。

##  auto

自 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。

C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。

```c++
auto f=3.14;      //double
auto s("hello");  //const char*
auto z = new auto(9); // int*
auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型
```

## register

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。

较少用。

## static

通常，声明时未加上 static 修饰符的局部变量具有局部生命期，称为**自动变量**。自动变量在进入声明该变量的块时被创建，在离开该块时被撤销。若多次进入和离开该块，则自动变量会多次被创建和撤销。

### 静态变量

在程序运行期间，静态变量只进行一次初始化。静态变量的初始化在执行 main 函数之前。

静态变量具有全局生命期，在程序开始执行时创建，在程序运行结束时撤销，其生命期与程序执行时间等长。

#### 静态全局变量

在声明时，在全局变量前加上`static`。

> 全局变量本身有全局生命期，因此定义全局变量时加 static 的作用是：限制该全局变量不会被别的文件引用。

> 不提倡使用全局变量，因此静态全局变量用的不多。

#### 静态局部变量

在声明时，在局部变量前加上`static`。

> 局部静态变量是局部变量。虽然该变量具有全局变量生命期，但是在其作用域之外是无法访问它的。

## extern

。。。

###  外部变量

定义性声明：带初始化表达式的外部变量声明；引用性声明：不带初始化表达式~。


> 局部变量默认为 auto（旧版），全局变量默认为 extern。

# 预处理指示
。。。

# 函数的接口设计和注释
。。。

# 递归

递归的特点：
- 有两个过程组成：追溯和回归。
- 其每一步的计算方案可用这个方案的一个更小版本或其基本条件来实现。

> 正确的递归程序必须是可终止的！
> 递归程序必须至少有一个基本条件，来确保它们最终会达到某个基本分支。

例子，计算 x 的 k 次方。

```c++
// 用递归方式求 x 的 k 次方

#include <iostream>
using namespace std;

// 函数原型
int power(int x, int k);

int main() {
  // 基, 幂次和结果
  int base, exp, result;

  cout << "enter the base and the exponent" << endl;
  cin >> base >> exp;

  result = power(base, exp);
  return 0;
}

int power(int x, int k) {
  // 终止条件
  if(k == 1) {
    return x;
  } else {
    // 计算 x 的 k-1 次方
    return x * power(x, k-1);
  }
}

```